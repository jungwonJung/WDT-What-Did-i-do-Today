# 컴퓨터의 구성
https://ganzicoder.tistory.com/112

컴퓨터가 가지는 구성은?

 

하드웨어, 소프트웨어 

 

하드웨어 : 컴퓨터를 구성하는 기계적장치 사람의 몸 

 

- 중앙처리장치(CPU)

   인간의 두뇌

    주기억장치에서 프로그램 명령어와 데이터를 읽고 처리, 명렁어의 수행순서를 제어

    중앙처리장치는 비교와 연산을 담당하는 산술논리연상장치와 명령어의 해석과 실행을

    담당하는 제어장치, 속도가 빠른 데이터 기억장소인 레지스터 로 구성

 

- 기억장치 (RAM, HDD, SDD)

   프로그램, 데이터, 연산의 중간 결과를 저장하는 장치

   주기억장치와 보조기억장치로 나누어지며 RAM 과 ROM 이 해당함쓰

   실행중인 프로그램과 같은 프로그램에 필요한 데이터를 일시적으로 저장 (단기기억)

   보조기억장치는 HDD를 말하며 주기억장치에 비해 속도는 느리지만 용량이 겁나게큼 

 

- 입출력장치: 마우스, 프린터, 키보드

  인풋과 아웃풋

  인풋은 컴퓨터 내부로 자료를 입력하는 장치 키보드 마우스

  아웃풋은 컴퓨터에서 외부로 표현하는 장치 

 

위의 3 가지는 시스템 버스로 연결되어 있으며, 시스템 버스는 데이터와 명령제어 신호를 각 장치로 

실어나르는 역할을 함

 

시스템버스?

-하드웨어 구성요소를 물리적으로 연결하는 선

 각 구성요소가 각각 다른 구성요소로 데이터를 보낼수 있게 통로가 되어줌

 용도에 따라 데이터, 주소, 제어 버스로 나뉘어짐

 

  -데이터버스

     중앙처리장치와 다른 장치사이에서 데이터를 전달하는 통로 (복도개념?)

     기억장치와 입출력장치의 명령어와 데이터를 중앙처리장치로 보내거나 

     중앙처리장치의 연산결과를 기억장치와 입출력장치로 보내는 양방향 뻐스

 

  -주소버스 

    데이터를 정확하게 실어나르려면 기억장치 '주소'를 설정해야한다고함

    주소버스는 중앙처리장치가 주기억장치나 입출력장치로 기억장치 주소를 

    전달하는 통로이기 때문에 단방향 뻐스

 

  -제어버스

     주소버스,데이터버스는 모든 장치에 공유되서 이를 제어해야하는 수단필요

     제어버스는 중앙처리장치가 기억장치나 입출력장치에 제어신호를 전달하는 통로

     제어신호종류 : 기억장치 읽기 및 쓰기, 버스요청 및 승인, 인터럽트 요청 및 승인 ,클락, 리셋 등

     제어버스는 읽기동작과 쓰기동작을 모두 수행하기때문에 양방향 뻐스

 

소프트웨어: 하드웨어의 동작을 지시하고 제어하는 명령어 집합 사람의 두뇌

 

- 시스템 소프트웨어 : 운영체제, 컴파일러

- 응용 소프트웨어 : 워드프로세서, 스프레드시트

 

 

컴퓨터는 기본적으로 읽고 처리하고 저장하는 과정으로 이루어짐 

 

이과정을 무한반복하면서 주기억장치 (RAM) 과 소통

만약 운영체제가 64bit 라면 CPU 는 RAM 으로부터 데이터를 한번에 64개씩 받는거임

 

# 중앙처리장치의 작동원리
https://ganzicoder.tistory.com/113

CPU는 컴퓨터에서 제일 핵심장치라 해도 무방 사람의 두뇌라 생각하면될듯

연산장치, 제어장치, 레지스터 3부분으로 구성되었다

 

-연산장치 

산술연산과 논리연산 수행( 산술논리연산장치라고 불림)

연산에 필요한 데이터를 

 

-제어장치

명령어를 순서대로 실행하게 제어하는 장치

 

주기억장치에서 프로그램 명령어를 꺼내서 해독하고, 해당 결과에 따라 명령어 실행에 필요한 제어신호를 

기억장치, 연산장치, 입출력장치로 보낸다

 

또한 이들 장치가 보낸 신호를 받아, 다음에 수행할 동작을 결정

 

 

-레지스터

고속 기억장치

명령어주소, 코드 , 연산에 필요한데이터, 연산 결과 등을 임시로 저장

 

용도에 따라 범용 레지스터와 특수목적 레지스터로 구분

 

중앙처리장치 종류에따라 사용할수있는 레지스터 개수와 크기가 다름

  - 범용 레지스터 : 연산에 필요한 데이터나 연산결과를 임시저장

  - 특수목적 레지스터 : 특별한 용도로 사용하는 레지스터

     MAR(메모리 주소 레지스터) : 읽기와 쓰기 연산을 수핼할 주기억장치 주소저장

     PC(프로그램카운터) : 다음에 수행할 명령어 주소저장

     IR(명령어 레지스터): 현재 실행중인 명령어 저장

     MBR(메모리 버퍼 레지스터): 주기억장치에서 읽어온데이터, 저장할 데이터 임시저장

     AC(누산기) : 연산결과 임시저장

 

 

CPU의 동작과정

- 주기억장치는 입력장치에서 입력받은 데이터 또는 보조기억장치에 저장된 프로그램을 읽어온다

- CPU는 프로그램을 실행하기위해 주기억장치에 저장된 프로그램 명령어, 데이터를 읽어서 처리하고

   결과를 다시 주기억장치로 보내서 저장

- 주기억장치는 처리결과를 보조기억장치에 저장하고,출력장치로 보냄

- 제어장치는 위의 3과정에서 명령어가 순서대로 실행되도록 각 장치를 제어

 

 

명령어 세트란?

CPU가 실행할 명령어의 집합

-연산코드 + 피연산자로 이루어짐

 연산코드 : 실행할 연산

 피연산자 : 필요한 데이터 , 저장위치

 

연산코드는 연산,제어,데이터 전달, 입출력기능을 가짐

 

피연산자는 주소, 숫자/문자, 논리 데이터 등을 저장

 

CPU는 프로그램 실행하기위해 주기억장치에서 명령어를 순차적으로 인출, 해독,실행과정 반복

 

CPU가 주기억장치에서 한번에 하나의 명령어를 인출하여 실행하는데 필요한 일련의 활동을 '명령어사이클'이라함

 

명령어 사이클은 인출/실행/간접/인터럽트 사이클로 나뉨

 

주기억장치의 지정된주소에서 하나의 명령어를 가져오고, 실행 사이클에서는 명령어를 실행

하나의 명령어 실행이 끝나면 그다음 명령어에 대한 인출 사이클 시작

 

 

인출 사이클과 실행 사이클에 의한 명령어 처리 과정

- 인출 사이클에서 가장 중요한부분은 PC 값 증가

  PC에 저장된 주소를 MAR 로 전달

  저장된내용을 토대로 주기억장치의 해당 주소에서 명령어 인출

  인출한 명령어를 MBR 에 저장

  다음 명령어를 인출하기위해 PC값 증가시킴

  메모리 버퍼 레지스터 (MBR)에 저장된 내용을 명령어 레지스터(IR) 에 전달

 
```
T0 : MAR ← PC
T1 : MBR ← M[MAR], PC ← PC+1
T2 : IR ← MBR
```

인출하기까지의 과정!!

 

인출한이후 명령어를 실행하는 과정

-ADD addr 명령어 연산

```
T0 : MAR ← IR(Addr)
T1 : MBR ← M[MAR]
T2 : AC ← AC + MBR
```

이미 인출이진행되고 명령어만 실행하면 되기때문에 PC를 증가할필요 없다

 

IR에 MBR 의 값이 이미 저장된 상태를 의미한다

 

따라서 AC에 MBR 을 더해주기만 하면된다 

# 캐시메모리
https://ganzicoder.tistory.com/114

캐시메모리

- 속도가 빠른 장치와 느린장치에서 속도 차이에 따른 병목현상을 줄이기 위한 메모리

   CPU 코어와 메모리 사이의 병목 현상완화

   웹브라우저 캐시파일은 HDD와 웹페이지사이의 병목현상을 완화

 

CPU가 주기억장치에서 저장된 데이터를 읽어올때 자주 사용하는 데이터를 캐시 메모리에 저장한뒤

다음에 이용할때 주기억장치가 아닌 캐시메모리에서 먼저 가져오면 속도 향상되지만

용량이 적기도하고 비용이 매우비쌈....

 

CPU에는 캐시메모리가 2~3개정도 사용됨 (L1, L2, L3 캐시메모리라 부름)

속도와 크기에 따라 분류한것 일반적으로 L1 캐시부터 먼저 사용

CPU에서 가장 빠르게 접근, 여기서 데이터를 찾지 못하면 L2로간다

 

듀얼코어프로세서의 캐시메모리 : 각 코어마다 독립된 L1 캐시 메모리를 가지고 두 코어가 공유하는 L2 캐시 메모리가 내장

 

L1캐시가 128kb 면 64/64 로 나누어 64kb에 명령어를 처리하기 직전의 명령어를 임시 저장하고

나머지 64kb에는 실행 후 명령어를 임시저장

L1 : CPU 내부에존재

L2 : CPU 와 RAM 사이에 존재

L3 : 보통 메인보드에 존재함

 

 

디스크 캐시 : 주기억장치와 보조기억장치 사이에 존재하는 캐시

 

캐시 메모리작동원리

 

- 시간 지역성

for 나 while 반복문에 사용하는 조건변수처럼 한번 참조된 데이터는 잠시후 또 참조될 가능성 높음

 

-공간 지역성

A[0] , A[1]처럼 연속 접근시 참조된 데이터 근처에 있는 데이터가 잠시후 또 사용될 가능성높음

 

캐시에 데이터를 저장시엔 참조지역성공간을 최대한 활용하기위해 해당 데이터뿐만 아니라

옆 주소의 데이터도 같이 가져와서 나중에 쓰일것을 대비해야한다

 

CPU 가 요청한 데이터가 캐시에있으면 캐시 Hit, 없을시 DRAM 에서가져오면 캐시 miss

 

 

캐시 miss 3가지

 

1.Cold miss

해당 메모리 주소를 처음 불러서 나는 미스

 

2.Conflict miss

캐시메모리에 A와 B데이터를 저장해야하는데 A와 B가 같은 캐시메모리 주소에 할당되어 있어서

생기는 미스

(direct mapped 캐시에서 많이발생)

3.Capacity miss

캐시메모리의 공간이 부족해서 생기는 미스 (Conflict 는 주소할당 , Capacity 는 공간문제)

 

캐시크기를 키워서 문제를 해결할려하면

캐시접근속도가 느려지고 파워를 많이먹음
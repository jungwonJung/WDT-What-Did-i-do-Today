# 다시하는 JavaScript 공부#2 (엘리님의 드림코딩)
https://ganzicoder.tistory.com/140

이번에도 내가맡은 파트를 정리해보았다

엘리님의 영상목록순서에서는 4회차에 해당하는 영상일것이다

```
String Concatation
말그대로 문자열을 순차적으로 결합하는것입니다 다른 방법으로는 concat(), join() 함수를 이용해 문자열을 합칠수도있다고합니다
// 1. string concatation (문자열 순차결합)
console.log("my" + "cat");
console.log("1" + 2);
console.log(`string literals : 1 + 2 = ${1 + 2}`);

console.log('jungwon's book')
// error
console.log("jungwon's book");
// jungwon'sbook
console.log("jungwon's \nbook");
// jungwon's book
console.log("jungwon's \n\tbook");
// jungwon's
// book
```

Numeric Operators 사칙연산
사칙연산은 컴퓨터의 기원을따라가면 컴퓨터가 왜생겼는지에대해 알수있는

중요한 이야기입니다

수많은 숫자들을 수많은 계산을 해야하는경우 사람의 힘으로는 부족하기에

사람은 이를 대체하기위해 컴퓨터를 개발했다고봐도 무방합니다

```
// 2.numeric operators (사칙연산)
console.log(1 + 1); // 더하기  2
console.log(1 - 1); // 빼기    0
console.log(1 / 1); // 나누기  1
console.log(1 * 1); // 곱하기  1
console.log(5 % 2); // 나누고 나머지값  1
console.log(2 ** 3); // 2의 3승  8
```

Increament and decrement operators 증감 연산자
증감연산자는 1을 증가시키거나 1을 감소시킬때 사용

증가시킬땐 ++, 감소시킬땐 — 를 사용합니다

증감연산자가 변수 앞에 올때랑 뒤에 올때랑 차이가 있습니다

앞에 있을경우엔 전체 수식을 처리하기전에 적용합니다

뒤에 있을경우엔 전체 수식 처리를 끝내고 적용시킵니다

 
```
let counter = 2;
const preIncrement = ++counter;
// 이말인즉슨 2인 카운터에 + 1 을 더한값을 preIncrement 가 된다
// counter = counter 는2 인데 + 여기에 1 을 더한다
// preIncrement도 3 = counter는 3
console.log(`preIncrement : ${preIncrement}, counter : ${counter}`);
preIncrement : 3, counter : 3

const postIncrement = counter++;
console.log(`preIncrement : ${preIncrement}, counter : ${counter}`);
// postIncrement도 3 = counter는 현재 3 인데 ++ 가 붙은거는 + 1을 한다는뜻
// counter 는 4 = counter는 3 인데 + 1 을 더하면
preIncrement : 3, counter : 4
```

assignment operators 두개를할당할수있는 연산자 (할당연산자)
할당연산자는 예제를 보면 이해하기쉽습니다

두개를 이어붙어서 사용하는경우라고 보면될것같네요

```
let x = 3;
let y = 6;
x += y; // x = x + y
x -= y; // x = x - y
x *= y; // x = x * y
x /= y; // x = x / y
```

```
comparison operators 비교 연산
x == y       x와 y의 값이 같다      
x === y      x와 y의 값과 타입(type)이 같다
x != y       x와 y의 값이 다르다
x !== y      x와 y의 값이나 타입(type)이 다르다
x > y        x의 값이 y의 값보다 크다
x >= y       x의 값이 y의 값보다 크거나 같다
x < y        x의 값이 y의 값보다 작다
x <= y       x의 값이 y의 값보다 작거나 같다
```

logical operators 논리 연산자 || or , && and , ! not
OR 연산자 (기호: || )

왼쪽과 오른쪽 중 하나라도 참이면 모두 true
왼쪽과 오른쪽 모두 거짓일 때 false
AND 연산자 (기호: && )

왼쪽과 오른쪽 중 하나라도 거짓이면 모두 false
왼쪽과 오른쪽 모두 참이어야 true
NOT 연산자 (기호: ! )

true나 false를 반대로 뒤집는다

```
//6. logical operators 논리 연산자  || or , && and , ! not
a = 1 < 2;
b = 2 < 1;
const or = a || b || c; // 인경우 하나라도 true인결과가 있으면 or = true
// 맨처음 a가 true이면 더이상 연산을 하지않고 or 가 true 라고 반환합니다
```

```
const and = a && b; // 모든결과가 true 여야만 and = true
// 맨처음 a 가 false 이면 더이상 연산을 하지않고 and 가 false 라고 값을 반환

// ! not
// true 를 false 로
console.log(!a); // a 는 true 니깐 false 로 바꿈
```

Equality == 같다면
위에 비교연산자쪽에 잠깐 설명을했지만

== 와 ===는 각각 다른 연산자이다

===는 타입과 값이 총 두가지의 조건이 같아야만 TRUE 를 반환

객체의 경우에는 ref 안에 각각의 key/value 값들이 저장되는것이기때문에 헷갈리지않게 확인을 잘해야한다 예제코드에 있는 문제들을 보면 쉽게 이해할수있을거라고 생각함

 
```
// 7. Equality
const stringFive = "5";
const numberFive = 5;

// ==
console.log(stringFive == numberFive); // 문자열이지만 안에들어간게 숫자와 같으면 같다고함
console.log(stringFive != numberFive);

// ===
console.log(stringFive === numberFive); // 타입도 동일해야함
console.log(stringFive !== numberFive);

// 객체 ==
const jung1 = { name: "jungwon" };
const jung2 = { name: "jungwon" };
const jung3 = jung1;
console.log(jung1 == jung2); // 값은 같지만 저장된 reference 가 다르기때문에 false refernce.name 이라생각하면됨
console.log(jung1 === jung2); // 타입 같은 유무와는 달리 ref 가 다르기때문에 그냥 다름
console.log(jung1 === jung3); // 같은 ref 를 표시

// 객체 문제
console.log("question", 0 == false); // 3강에서 0, null, empty ,undefined 는 다 false
console.log("question", 0 === false); // 0 != boolean
console.log("question", "" == false);
console.log("question", "" === false); // '' != boolan
console.log("question", null == undefined); // 값이 없기땜에 같음
console.log("question", null === undefined); // 값이 진짜 없는건 null 못찾는건 undefined 그래서 타입은다름
```

 

조건문 IF문
조건문은 말그대로 내가 코드를 작성함에있어서

원하는 값을 출력할때 조건을 걸어서 해당값이 맞는지 아닌지

true/fasle 로 내가 원하는값을 출력하는 것을 말한다

if 문은 조건문중에 만약에 라는 의미를 갖고있다

Tereny Operator 도 동시설명 조건부 삼항 연산자는 JavaScript에서 세 개의 피연산자를 취할 수 있는 유일한 연산자이다 보통 if 문의 단축 형태로 쓰임

 
```
const name = "df";
if (name === "jung") {
    console.log("hi");
} else if (name === "won") {
    console.log("hello");
} else {
    console.log("unkwnon");
}
// name = df 인데
// 만약 name 이 jung 이면 hi 를 출력하고
// 만약에 name 이 won 이면 hello 를 출력하고
// 둘다 아니면 unkwnon 을출력해라

//9.Ternary Operator : ?
console.log(name === "jung" ? "yes" : "no");
// name 이 jung 이니? true 면 왼쪽의 yes , false 면 오른쪽의 no 를 출력
```

Switch Statement
if 문이라는 조건문이 존재하긴하지만

조건문에서 비교할값이 많아진다면 코드가 엄청나게

길어질것이고 가독성이 떨어질겁니다 그렇다면 유지보수하는과정에서

힘들어지겠죠? 그걸 방지하기위해 switch 라는 조건문을 사용해줍시다

```
const car = "hyndai";
switch (car) {
    case "hyndai":
        console.log("hi");
        break;
    case "kia":
    case "benz":
        console.log("hello");
        break;
    default:
        console.log("no car");
        break;
}
```

 

반복문 While
반복문은 쉽게 말하면 내가 선언한 조건이 true 면 계속반복하고

false 면 해당 동작을 그만두는것입니다

```
let i = 3;
while (i > 0) {
    // 선언한 조건이 false 가 될때까지 동작
    console.log(`while : ${i}`);
    i--; // 동작
}
// 조건문이 맞을때만 동작을실행

//
do {
    console.log(`do while : ${i}`);
    i--;
} while (i > 0);
//블록을 먼저실행하고싶은경우
```

condition 반복문
for 반복문이라고도 하며 while 반복문과 동일하게 특정 조건이 거짓이될때까지 반복합니다

구성은 이렇습니다

초기문 ; 조건문 ; 증감문

1. 초기문이 존재한다면 초기문이 실행 출력

2. 조건문은 조건을 검사 , 조건문이 true 면 반복문 실행 false 면 반복문 종료

3.증감문이 존재한다면 한번실행하고 다음반복문으로 진행

 
```
//
do {
    console.log(`do while : ${i}`);
    i--;
} while (i > 0);
//블록을 먼저실행하고싶은경우

// 컨디션 반복문
for (i = 3; i > 0; i--) {
    console.log(`for : ${i}`);
}
// 3이라고 출력한뒤 컨디션과 스텝만 무한반복
// 컨디션 조건에 안맞으면 실행취소

for (let i = 3; i > 0; i = i - 2) {
    console.log(`inline variable for: ${i}`);
}
``` 

제가 직접 적고 정리한내용입니다

예제코드는 조금씩차이가 있을수도있습니다 ㅎㅎ

틀린정보가 있다면 지적해주세요!!


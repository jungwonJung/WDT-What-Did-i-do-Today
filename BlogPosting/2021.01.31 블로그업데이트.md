# Java script 스코프와 호이스팅
https://ganzicoder.tistory.com/81

스코프와 클로저는 매우 중요한 개념중 하나

스코프와 클로저는 서로 연관이 깊은 개념이라

헷갈리거나 어려워하는 경우가 많음 클로저는 특히 어렵기도함

 

유효 범위(Scope)란?

 

scope의 사전적의미는 범위 이다

Javascript 에서 스코프란 작성된 코드를 둘러싼 환경을 말한다

어떤 변수들에 접근할수있는지를 정의한다

어떤 범위내에 속해있는지를 정의한다면 사전적의미와 매우유사

스코프는 전역(global) 과 지역(local) 스코프로 정의가능

 

전역스코프(global scope)

 

함수안에 포함되지 않은곳에 정의 하는것

코드 어디에서든 참조가능

 

지역스코프(local scope)

 

함수 내에 정의된 것으로 정의된 함수내에서만 참조가능

 

다른 언어에서의 지역변수와 전역변수와 비슷한의미를 가지고있음

하지만 자바스크립트에서의 스코프는 다른언어와 다른 특징을 지니고있고

Function - level scope (함수 레벨 스코프) 를 사용한다는 특징이있다

 

대부분의 언어는 Block - level scope(블록 레벨 스코프) 를 사용함

변수선언이 코드 블록단위로 유효하다

Function - level scope (함수 레벨 스코프) 인 자바스크립트는

함수 블록내에서 선언된 변수는 함수블록 내에서만 유효하고

함수 외부에서는 참조 할수가 없다

 

다른 언어의 경우 블록 단위이기때문에 아래와 같이 if 나 for문에서 선언된 변수들은

중괄호 범위 밖에선느 사용 불가능하다

 
```
function foo() {
    if (true) {
        var a = 0; 
        console.log(a);
    }
    console.log(a); 
}
```

자바스크립트에서는 함수 레벨 스코프이기에 중괄호밖에서 a를 출력하는것이 가능

 

단,ES6 부터는 const 와 let 을 이용해 블록 레벨 스코프도 지원하기시작함

따라서 if 문 안에 var 대신 const 나 let으로 변수를 선언하면

다른 언어들처럼 참조 불가능

const 와 let 은 블록레벨스코프

var 처럼 전통적인 자바스크립트의 변수는 함수레벨스코프 이다

 

전역 스코프(Global scope)와 지역 스코프(Local scope)
 

변수가 함수 바깥이나 중괄호{} 바깥에서 선언되면 전역 스코프에 정의되었다고 말한다

전역 스코프에 변수를 선언하면 코드 어디에서나 해당 변수를 사용가능

함수안에서도 가능하다

지역 스코프는 함수내의 범위로 각각의 함수마다 자신의 지역스코프를 가지고있음

어떤 함수 내 지역스코프에 선연된 변수가 있다면 

그 함수를 벗어난 범위에서는 그변수를 참조 할수 없음

당연하게도 각각 선언된 함수가 있다면 서로의 스코프에 있는 변수는 참조 불가능

 
```
var global_scope = 'global';  // 전역 스코프

var local_function = function() {
    var local_scope = 'goorm';  // 지역 스코프
    console.log(global_scope);  // 전역 스코프 참조 가능. global 출력
    console.log(local_scope);  // 함수 내이기 때문에 지역 스코프 참조 가능. goorm 출력
};

console.log(local_scope);  // local_scope은 지역스코프이기 때문에 에러 발생.
```

함수를 벗어나면 쓰지 못하는 지역 스코프보다 전역 스코프가 더 편하다고 생각할수도 있지만

전역 스코프에 변수 선언을 하지 않는것이 매우 좋음

그 이유는 변수의 이름이 충돌할 가능성이 있기 때문

혼자서만 개발하는게 아니고 다른사람의 코드를 사용하는 협업의 경우

흔한 이름일 경우 변수의 이름이 겹치고 에러가 발생한다

 

유효 범위 체인(Scope Chain)
자바스크립트는 함수 단위의 범위를 지니고있다

그러므로 서로 다른 함수끼리는 참조가 불가능

함수 안에 함수가 들어있는 경우엔???

 
```
var a = 1;

function outer() {
	var b = 2;
	console.log(a); // 1
	
	function inner() {
		var c = 3;
		console.log(b);
		console.log(a); 
	}
	
	inner();  // 2 1
}
outer();

console.log(c);  // c is not defined
```

위에 코드와 같이 함수를 정의하면 제일 안쪽의 함수인 inner 는 그 위쪽 범위까지 흡수하게된다

이러한 경우를 유효범위체인 이라고 일컫는다

흔히 스코프 체인이라 말한다

한 변수가 특정 함수내부에서 정의되면 그 함수 밖에서는 존재하지 않는것처럼 보인다

외부에서는 안에 있는 함수의 변수를 참조할수없지만

안에 있는 함수에서는 외부의 변수를 사용할수있다

 

a는 전역공간에서 선언되었고 inner 와 outer 함수에서 사용가능

변수 c는 함수 내부블록에서 선언 함수의 밖인 전역범위에서는 인식불가

outer 함수에서도 c변수는 사용하지못한다

inner 함수 안에서 상위 스코프인 b변수와 a변수 모두 사용가능

 

inner 함수에서 a변수를 참조할때 먼저 자기 자신의 스코프에서 a 를 찾고

없으면 상위 스코프인 outer 함수의 스코프에서 a 를 찾고

거기에도 없으면 또 다시 상위 스코프인 전역범위로 올라가 a 를 찾는다

최종적으로 전역 스코프에도 찾는 변수가 없으면 not defined 라는 에러를 출력

이렇게 체인처럼 꼬리에 꼬리를 물고 상위 스코프를 참조하기때문에 스코프 체인 이라 한다

 

정적 범위(Lexical scope)
렉시컬 스코프란?

렉시컬스코프는 전역스코프와 지역 스코프처럼 기본적인 자바스크립트의 특징아

 

lexical 의 사전적인의미는 "어휘의" 라는 의미지만 번역하면 더이상하다

렉시컬스코프를 이해하려면 정적 범위, 정적 스코프라고 생각해야한다

함수를 어디서 호출하는지가 아니라

어떤 스코프에 선언하였는지에 따라 결정된다는 것이다

```
var text = 'global';

function foo() {
	console.log(text);
}

function bar() {
	var text = 'bar';
	foo();
}

bar(); // 무엇이 출력될까요?
// global 이 출력된다
```
 

text 변수가 global 에서 bar 로 바뀌었으니 bar 출력될거같지만 아니였다

 

foo 에서 출련한 text 는 bar 함수의 지역변수 text 가 아니라 전역 변수 text 를 가르키고 있다

위에 설명했던 스코프체인 과도 연관이 있는 개념이다

먼저 foo 함수에서 text 를 참조할때

자기 자신의 스코프에서 text 를 먼저 찾아보고 없기떄문에 상위 스코프인 전역 스코프에서 text 를 찾아서

출력하게 된다

 

문제는 bar 함수에서 foo 함수를 불러오는것인데 foo 함수는 text 를 참조해야하니까 상위 스코프인 bar 함수에서

text 를 찾을거라 생각할수 있지만 아까 위에서 말했듯이 "어디서 호출하는지가 아니라 처음 선언되었을때에 어떤

스코프에 있는지가 " 중요하다

스코프란 코드를 실행하면서 바뀌는것이 아니라 처음 작성한 그 스코프로 결정된다는 것이다

 

foo 에서 bar 에서 호출되든 어떤 힘수 안에서 호출되든지 상관없이 무조건 자기 자신의 스코프를 찾아보고

전역스코프를 찾는다 

 

호이스팅(hoisting)
 

hoisting 의 사전적 의미는 끌어올리기 입니다

호이스팅도 자바스크립트의 특징 중 하나인데

말 그대로 함수 안에서 변수를 선언할때 어떤 위치에 있든 함수의 시작위로 

끌어올리는 현상이다

단 선언부분만 위로 끌어올리고 값을 대입하는 부분은 위치 그대로 남아있다

```
function foo() {
	console.log(a);  // undefined
	var a = 100;
	console.log(a);  // 100
}

foo(); 
// undefined
// 100
```

다른 프로그래밍언어의 경우 위의 코드를 실해하면 a 가 선언되지 않았는데 a 를 호출했기때문에 에러가 발생합니다

하지만 자바스크립트의 경우는 호이스팅을 통해 a 의 선언을 함수 재알 위에서 해주기 때문에 에러 없이 

undefined 가 출력된다

 
```
foo();

function foo() {
	console.log('출력');
}
// 출력
위와 같이 변수 호이스팅과 마찬ㄹ가지로 함수선언이 위로 끌어올려지때문에 제대로 동작한다

 

foo();  // foo is not a function

var foo = function() {
	console.log('출력');
};
// 에러발생
위의 코드는 에러를 발생한다

 그이유는??

사실 에러가 발생한 코드는 아래의 코드와 동일하다

var foo;

foo();  // foo is not a function

foo = function() {
	console.log('출력');
};
// 에러발생
```

위와 같이 foo 선언을 위로 호이스팅 해버리기 때문에 foo 가실행될때는

아직 변수로 선언이 된 상태일 뿐이다 

따라서 foo 는 함수가 아니라는 에러를 보게된다

호이스팅으로인한 혼란을 야기하기전에

함수를 호출하기 전에 최상단에 선언 하는 습관을 길러야함
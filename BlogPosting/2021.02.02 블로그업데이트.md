# Java script 클로저란?
https://ganzicoder.tistory.com/82

자바스크립트는 클로저 라는 개념을 가지고있음

스코프체인과 연관되어 있음으로 스코프 체인에 대한 개념을 이해해야만 한다

 

일반적으로 외부 함수의 실행이 끝나면 외부 함수가 소멸되어 내부 함수가 외부 함수의 

변수에 접근할수 없다

하지만 

"외부 함수의 실행이 끝나고 외부 함수가 소멸된 이후에도 내부 함수가 외부 함수의 변수에

접근 할 수있는구조"

를 클로저 라고 한다

쉽게 말하면

자신의 고유 스코프를 가진 상태로 소멸하지 않고 외부 함수에 의해 호출되는 함수를

만드는 것이 클로저이다

 

클로저가 중요한이유는 

클로저는 자바스크립트가 가진 하나의 큰 특징이자 Node.js 가 높은 효율성을 

가지게해주는 근간이기 때문

 

본래 자바스크립트에선 함수가 호출되면 메모리에 할당되고 함수가 종료되면 메모리에서 해제되기때문에

함수별로 선언된 지역변수들은 호출할때마다 같은값으로 초기화된다 

하지만 함수를 호출할때 이전에 쓰던값을 유지하고 싶다면

클로저를 사용하자

 
```
var num = 1;

function foo() {
	var num = 2;
	
	function bar() {
		console.log(num);
	}
	return bar;
}

var baz = foo();
baz();

// 2 
```

2가 출력되지만 

foo() 함수는 리턴되어 사라진후에 내부함수 bar 가 생성되는데 

여전히 내부함수인 foo의 지역변수에 접근할수있을까

 

가능은 합니다 .외부함수가 리턴되어 사라져야 하는데

사라지지않고 내부함수의 참조로 인해 값을 유지하게 되는것을 클로저 라고부른다

위의 코드는 간단한 편이지만 이것도 클로저라 할수있음 

정확히는 내부함수를 클로저 함수라 한다 

bar() 가 클로저 함수가 된다

```
function f(arg) {
	var n = function() {
		return arg; 
	}
	arg++;
	return n; 
}

var m = f(123); 
console.log(m());
// 124
```

f(123)을 실행하게되면 함수 n 에서 이미 arg 를 반환하였기에 n 이가지는 범위에서

arg 값은 123 이라 생각할수있지만

함수 n 은 함수 f의범위에 있는것을 참조하고 있기에

함수 f에서 모든처리가 끝나야 함수n이 처리된다

 

따라서 f(123)은 124 가 된다

 

클로저를 배울때 for 문을 이용하는 것이 가장 직관적이기 때문에 

for 문을 통한 예시를 보도록합시다르

```
function f() {
    var a = [];
    var i;
	
    for(i = 0; i < 3; i++){
      a[i] = function() {
        return i;
        }
    }
    return a;
  }
  
  var b = f();

  console.log( b[0]() ); 
  console.log( b[1]() ); 
  console.log( b[2]() ); 
  
  // 3
  // 3
  // 3
```

```
a[i] = function() {
    return i;
}
```

는 함수선언만 된거고 실제로 함수가 실행되는것은 console.log( b[0]() ) 줄에서 이루어지는데

var b = f() ; 문장에서 for 문의 실행이 다 끝나고 나서야 실제 참조가 이루어진다 

따라서 i 값이 이미 3으로 증가했기에 전부 3이 출련된다

 

즉 클로저는 그 순간의 값을 저장하는것이 아니라 연결된 함수 범위에서 최종 처리된값을

가지게 된다

 

클로저를 이용해서 정상적으로 0 1 2 가 출력되게 

동작시켜보자

```
function f() {
    var a = [];
    var i;
	
    for(i = 0; i < 3; i++){
      a[i] = (function(x) { 
        return function() {
          return x;
        }
      })(i);
    }
    return a;
  }
  
  var b = f();

  console.log( b[0]() );
  console.log( b[1]() );
  console.log( b[2]() );
  
  // 0 
  // 1 
  // 2
```

function 내부의 변수인 i를 바로 리턴하지 않고, 파라미터를 받는 function을 정의한 다음에 파라미터로 

내부 변수 i를 넘겨서 클로저가 내부변수 i가아니라 파라미터를 리턴하도록 하는 방법이다

 

function f() 내부에서 a[i] = (function(x) { ... })(i) 로 파라미터를 받는 함수를 이미 실행햇다는 것에 

주의해야한다

파라미터는 0,1,2를 차례로 받고 나중에 console.log( b[0]() ) 실행하더라도 파라미터를 기억하고 

있다가 0,1,2를 차례로 리턴하게 됩니다

 

함수 내에서 사용된 지역변수는 해당 함수의 실행이 종료되면 파기되는데

이와 같이 클로저 함수에 의해 계속 참조되고있는경우에는 해당 지역 변수를 파기하징낳고

계속 보관하고있다

 

클로저를 사용하면 함수를 호출할때마다 기존에 생성했던 값을 유지할수있기에 

전역변수의 잘못된 사용없이 깔끔한 코드 작성을 할수있다

또한 외부에 해당변수를 노출시키지 않아서 안정을 보장한다

캡슐화와도 관련이 있는데 

클로저를 통해서만 해당 변수를 참조하기에 외부 사용자가 값을 변경하지 못한다

 

클로저로 참조하는 변수는 프로그램 종료시까지 계속 메모리에 할당되니깐

 메모리 누수로 인한 성능저하의 원인이 될수도있다

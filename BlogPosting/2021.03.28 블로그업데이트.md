# 고정 소수점, 부동 소수점 's
https://ganzicoder.tistory.com/115

컴퓨터에선 실수를 표현하는 방법에는

고정 소수점 , 부동 수소점 두가지 방식이 존재

 

고정 수소점 

소수점이 찍힐 위치를 미리 정해놓고 소수를 표현하는 방식 (정수+소수)

-3.141592는 부호(-)와 정수부(3), 소수부(0.141592) 3가지 요소 필요함
부호 = 1비트

정수부 =15비트

소수부 = 16 비트

총 32비트

 

장점 : 실수를 정수부와 소수부로 표현하여 단순

단점 : 표현의 범위가 너무 적어서 활용하기 힘들다 

 

 

부동 소수점

실수를 가수부 + 지수부로 표현한다

-가수 : 실수의 실제값 표현

-지수 : 크기를 표현함, 가수의 어디쯤에 소수점이 있는지 나타낸다

지수의 값에 따라 소수점이 움직이는 방식을 활용한 실수 표현 방법

소수점의 위치가 고정되어 있지않음

 

부호 = 1 비트

지수부 = 8비트

가수부 = 23비트

총 32 비트

 

장점 : 표현할 수 있는 수의 범위가 넓어진다 ( 대부분의 시스템에서 활용중)

단점 : 오차가 발생할수 있다 (부동소수점으로 표현할수있는 방법이 매우다양)


# 패리티 비트 , 해밍 코드's
https://ganzicoder.tistory.com/116

패리티비트

정보 전달 과정에서 오류가 생겼는지 검사하기 위해 추가하는 비트를 말함

전송하고자 하는 데이터의 각 문자에 1비트를 더하여 전송

 

-종류 : 짝수, 홀수

전체 비트에서 (짝수, 홀수) 에 맞도록 비트를 정함

 

짝수패리티일때 7비트 데이터가 1010001 일경우?

-1이 총 3개이므로 짝수로 맞춰주기위해 1을 더해야함

-답 : 11010001(맨앞이 패리티비트)

 

해밍코드

데이터 전송시 1비트의 에러를 정정할수있는 자기 오류정정 코드를 말함

패리티비트를 보고 1비트에 대한 오류를 정정할 곳을 찾아 수정가능

(패리티 비트는 오류를 검출하기만하고 수정하지는 않기에 해밍코드를 활용)

 

-방법

2의 n승 번째 자리인 1,2,4 번째 자릿수가 패리티 비트라는 것으로 부터 시작

이 숫자로부터 시작하는 세개의 패리티 비트가 짝수인지 홀수인지 판별

 

짝수패리티의 해밍 코드가 0011011일때 오류가 수정된 코드는?

1. 1,3,5,7 번째 비트 확인 : 0101로 짝수이므로 0

2. 2,3,6,7 번째 비트 확인 : 0111로 홀수이므로 1

3. 4,5,6,7 번째 비트 확인 : 1011로 홀수이므로 1

 

역순으로 패리티비트 110 을 도출햇을 경우

10진법으로 바꾸면 6 ,6번째 비트를 수정하면됨

정답은 0011001 이다

# JavaScript Data Structure(자바스크립트 자료구조)
https://ganzicoder.tistory.com/117

Array 배열 

자바스크립트의 array는 순수한 배열이 아닌 링크드 리스트 기반 Hash Map입니다

하지만 여기서는 Array를 하나의 배열로생각, 간단한 예제문 진행

Array를 관리하는 내장 함수 학습해보기

 

- Array 를 이용해 길이 5 이상의 string 배열 만들기

- Array 를 이용 기본적인 내장 함수 (push, pop, shift, unshift, indexOf, splice, slice)

  사용하기

- Array 를 이용 심화 내장함수 (map, filter, find , keys , concat, flat, entries, includes)

  사용하기

 
```
const fruits = ['사과','바나나','파인애플','멜론','수박']
  fruits.push("망고");
  console.log(fruits);
  console.log(fruits.pop()); // pop 마지막 아이템을 제거 합니다.
  console.log(fruits.shift()); // 배열의 첫번째 아이템을 제거한다
  console.log(fruits.unshift("딸기"));// 배열의 앞에 딸기 추가
  console.log(fruits);
  console.log(fruits.indexOf("바나나"));
  console.log(fruits.shift());
  console.log(fruits.splice(0,1)); // 기존 요소를 삭제하거나 교체 새 요소 추가
  console.log(fruits);
  
  const FruitsCopy = fruits.slice(1,3);
  console.log(fruits)
  console.log(FruitsCopy)
  
  // *map 실습*
  const array1 = [1, 4, 9, 16];
  // pass a function to map
  const map1 = array1.map(x => x*2);
  console.log(map1) // output : [2, 8, 18, 32]
  
  
  // *filter* 
  const words = ["spray", "limit", "elite", "exuberant", "destruction", "present"];
  const result = words.filter(word => word.length > 6);
  console.log(result) // ["exuberant", "destruction", "present"]
  
  // *find* -> find() 는 주어진 판별 함수를 만족하는 첫 번째 요소의 값을 반환
  const array2 = [5, 12, 8, 130, 44];
  const found = array2.find(element => element > 10);
  console.log(found) //12
  
  // *key* -> 배열의 각 인덱스를 키 값으로 가지는 새로운 Array Iterator 객체 반환
  const array3 = ['a','b','c'];
  const ilterator = array3.keys();
  
  for (const key of ilterator) {
      console.log(key)
  } // 0, 1, 2
  
  // *concat* -> 배열 합치기
  const array4 = ['a', 'b', 'c']
  const array5 = ['d', 'e', 'f']
  
  console.log(array4.concat(array5)) //[a,b,c,d,e,f]
  
  // *flat* -> 중첩 배열 이어 붙혀 주는 
  // const array6 = [1, 2, 3 [4, 5, 6]];
  // array6.flat();
  
  // *etnries*  -> 배열의 각 인덱스에 대한 키/값 쌍을 가지는 새로운 객체를 반환
  const array7 = ['a', 'b', 'c'];
  const ilterator7 = array7.entries();
  console.log(ilterator7.next().value)// (0,'a')
  
  //includes -> 배열에 특정 요소를 포함 하고 있는지 확인
  const array8 = [1,2,3]
  console.log(array8.includes(2)) //true
```

 

List , 리스트

자바스크립트의 Array는 순수한 배열이 아닌 링크드 리스트 기반 Hash Map 

일부터 Linked List를 직접 구현해보자

 

-리스트 요구사항

 

하나의 연속되는 항목들이 포인터로 연결

마지막 항목은 Null을 지칭

프로그램이 수행되는 동안 크기가 커지거나 작아질 수 있음

(시스템 메모리가 가능한) 필요한 만큼 길어질 수 있다

메모리 공간을 낭비 안 함 (포인터를 위한 추가의 메모리 필요할 수 있음)

데이터의 삽입과 삭제가 가능해야 한다

 

Linked List , 링크드 리스트

배열과 자주 비교되곤 함

- 데이터의 추가/삽입 및 삭제가 용이

 

  배열은 데이터를 중간에 삽입하면 다른 데이터들의 위치를 모두 바꿔줘야 해서

  0(n)의 시간이 소요

 

  반면 링크드 리스트는 데이터를 중간에 삽입하면 링크의 연결만 조정해주면 돼서 

  0(1)의 시간이 소요

 

- 데이터의 검색 소도가 떨어짐 배열에 비해

   

  배열에서 인덱스만 알면 값을 읽는데 0(1)이 소요되지만

  링크드 리스는 각 노드가 다음 노드의 주소만을 가지고 있어서 

  최악의 경우 모든 요소를 순회하는 0(n)이 소요됨

```
const Node = value => {
  return { value, next: null }
}

const list = {
  head: null,
  tail: null,
  add(value) {
    const newNode = Node(value)

    if (list.head) {
      const tailStore = list.tail
      list.tail = newNode
      tailStore.next = list.tail
    } else {
      list.head = newNode
      list.tail = newNode
    }
  },
  removeHead() {
    if (list.head) {
      const headStore = list.head.value
      list.head = list.head.next

      if (list.head === null) {
        list.tail = null
      }

      return `${headStore} is removed`
    }

    return "list is empty"
  },
  contains(value) {
    let head = list.head
    while (head) {
      if (head.value === value) {
        return true
      }
      head = head.next
    }

    return false
  },
}
```

Queue, 큐

- FIFO (First In First Out) 형태로 데이터의 삽입과 삭제가 일어남

- 데이터를 삽입하는 enqueue와 삭제하는 dequeue를 구현

 

Stack , 스택

-LIFO (Last In First Out) 형태로 데이터의 삽입과 삭제가 일어남

- 데이터를 삽입하는 push와 삭제하는 pop을 구현

- 읽기 : peek

 

Graph , 그래프

- 하나의 노드는 특정한 값을 가지고 있음

- 하나의 노드는 하나이상의 에지를 지닐 수 있다 단, null도 허용

- 그래프의 데이터 느 선언 시 결정

단 추가 혹은 삭제 기능을 포함해 구현하면 좋음

 

Tree, 트리

- 여러 트리 형태 중 가장 기본적인 트리의 형태를 구현하는 것을 목적

 

 

Map, 맵

key-value로 이루어진 자료구조

object와 유사하지만 중요한 차이가 있다 

object는 프로토타입을 가지고있어서 의도치않은 key 충돌 생길 가능성 있음

하지만 map 은 명시적으로 제공된 key 만을 지니고 있음

또한 object의

또한 map의 key 값으로는 아무 아무 아무거나 싹 다 사용 가능하다

 

 

Set, 셋

map 은 key를 넣으면 value를 준다

set 은값만 모여있고 중복 값을 허용 안 한다

const foo = new Set([1, 2, 3, 4, 3, 2, 4, 5])

console.log(foo) //Set(5) {1, 2, 3, 4, 5}


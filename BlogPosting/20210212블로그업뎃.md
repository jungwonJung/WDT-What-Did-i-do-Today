# HTTP 란 무엇인가?
https://ganzicoder.tistory.com/91?category=904625

HyperText Transfer Protocol

의 약자 

하이퍼 텍스트 문서를 교환하기위해 사용된 통신 규약

웹 서버 와 클라 간의 통신 하기위한 규약

1989년 팀 버너스-리에 의해 처음 설계되어 월드와이드웹(www) 기반에서 

전 세계적인 정보공유를 이뤄냄

HTTP는 웹에서만 사용하는 프로토콜로 TCP/IP 기반으로 한지점에서 다른지점으로

요청과 응답을 전송

 

HTTP 메시지는 HTTP 서버와 HTTP 클라에 의해 해석이 된다

 

TCP/IP를 이용하는 응용 프로토콜(application protocol)이다

 

HTTP는 연결 상태를 유지하지 않는 비연결성 프로토콜

(이러한 단점을 해결하기 위해 Cookie와 Seesion 등장)

 

HTTP는 연결을 유지하지 않는 프로토콜이기 떄문에

요청/응답(request/response) 방식으로 동작한다

 

클라이언트 (사용자) 가 브라우저를 통해 어떤 요청을 URL을 통하거나 다른 것을 통해 요청하면

서버에선 요청사항에 맞는 결과를 찾아 사용자에게 응답 한다

 

요청 : 클라이언트 -> 서버

응답:  서버 -> 클라이언트

 

Request

 

클라이언트가 서버에게 연락하는 것을 요청이라 하고 요청을 보낼때는 요청에 대한 정보를 

담아 서버에 전달

 

Request method

 

GET : 자료를 요청할때 

POST : 자료의 생성을 요청할때

PUT : 자료의 수정을 요청할때 

DELETE : 자료의 삭제를 요청할때

 

 
```
GET https:/블라블라 HTTP/1.1								// 시작줄
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) ...			  // 헤더
Upgrade-Insecure-Requests: 1
```

GET  :  HTTP method

https://블라블라  : 사이트주소 

HTTP/1.1 : HTTP 버전

 

두번째 줄 은 헤더이며 요청에대한 정보를 담고있다

User-Agent, Upgrade-Insecure-Requests 등등이 헤더에 해당되며 헤더의 종류는 매우 많다.

 

본문은 헤더에서 한줄 띄고

요청을 할때 함께 보낼 데이터를 담는 부분 

예시에는 단순히 주소로만 요청을 보내고있어서 본문이 비어있음

 

 

Response (응답)

서버가 요청에 대한 답변을 클라에게 보내는것

 

Status Code (상태 코드)

상태 코드에는 굉장히 많은 종류가 있다. 모두 숫자 세 자리로 이루어져 있으며, 아래와 같이 크게 다섯 부류로 나눌 수 있다

-1XX (조건부 응답) : 요청을 받았으며 작업을 계속한다.
-2XX (성공) : 클라이언트가 요청한 동작을 수신, 이해했고 승낙함, 성공적으로 처리했음을 뜻한다
-3XX (리다이렉션 완료) : 클라이언트는 요청을 마치기 위해 추가 동작을 취해야 한다.
-4XX (요청 오류) : 클라이언트에 오류가 있음을 나타낸다.
-5XX (서버 오류) : 서버가 유효한 요청을 명백하게 수행하지 못했음을 나타낸다.

 
```
HTTP/1.1 200 OK							// 시작줄
Connection: keep-alive				 		// 헤더
Content-Encoding: gzip												 
Content-Length: 35653
Content-Type: text/html;

<!DOCTYPE html><html lang="ko" data-reactroot=""><head><title...
```

시작줄 

버전 상태코드 상태로 구성 200은 성공적인 요청이란 뜻

 

헤더

두번째줄 헤더로 응답에 대한 정보를 담고있음

 

본문

헤더뒤부터

응답엔 대부분의 경우 본문이 있음

데이터를 요청하고 응답메시지엔 요청한 데이터를 담아서 보내주기 때문

응답 메시지엔 HTML이 담겨있고 

이 HTML 을 받아서 브라우저에 화면 렌더링

 

 

참조 :

velog.io/@sejong202/HTTP%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C%EC%9A%94

# 인터넷은 어떻게 동작하는가?
https://ganzicoder.tistory.com/92

네트워크의 각 컴퓨터는 라우터라는 소형 컴퓨터에 서로 연결됨,

 

B에게 메시지를 보내려면

A가 메시지를 라우터로 보내면

라우터가 B로 메시지를 전달하고 다른곳으로 안가게 한다

 

컴퓨터를 라우터에 연결하고 라우터를 라우터에 연결하면 무한한 확장가능

 

이미 설치된 전화시설과 네트워크를 모뎀으로 연결

네트워크 정보를 전화 시설에서 처리가능한 정보로 변환한다

네트워크를 인터넷 서비스 제공업체(ISP)에 연결, ISP 는 모두 연결되는 특수한 라우트를 관리하고

다른 ISP라우터에도 액세스 가능하다

네트워크에 연결된 모든 컴퓨터에는 고유 IP주소가 있다 하지만 기억하기어려우니

도메인이름이라는 사람이 읽을수 있는 이름으로도 지정가능

# 브라우저의 동작원리는?
https://ganzicoder.tistory.com/93

V8 엔진으로 빌드된 JS 런타임 환경인 Node.js 의 등장으로 JS는 웹 브라우저를 벗어나

서버사이드 애플리케이션 개발에서도 사용되지만 JS가 가장많이 사용되는 분야는 웹 브라우저 환경에서 동작하는

웹페이지/애플리케이션이다

 

프로그래밍 언어의 대부분은 운영체제(OS)위에서 실행되지만

웹 애플리케이션의 JS 는 브라우저에서 HTML,CSS 와 함께 실행된다

브라우저환경을 고려할때 좀더 효율적인 JS 프로그래밍이 가능하다

 

브라우저의 핵심기능은 사용자가 참조하려는 웹페이지를 서버에 요청,응답을 받아

브라우저에 표시 브라우저는 서버로부터

HTML,CSS,JS,이미지 파일 등을 응답받는다

 

HTML,CSS 파일은 렌더링엔진의 HTML ,CSS 파서에 의해 파싱 되어 DOM,CSSOM 트리로 변환 , 렌더 트리로 결합

 

이렇게 생성된 렌더트리를 기반으로 브라우저는 웹페이지를 표시한다

 

JS는 렌더링엔진이 아닌 JS엔진이 처리한다

HTML 파서는 script 태그를 만나면 JS 코드를 실행하려고

DOM 생성 프로세스를 중지하고, JS엔진에 제어 권한을 넘긴다 ,

넘겨받은 JS 엔진은 script 내의 JS 코드 또는

script태그의 src 어튜리뷰트에 정의된 JS 파일을 로드,파싱 하여 실행하고

완료되면 다시 HTML 파서로 제어권한을 다시 넘겨서

브라우저가 중지했던 시점에서부터 DOM 생성을 재개한다

 

브라우저는 동기 적으로 HTML,CSS,JS 를 처리한다

script 태그의 위치에 따라 블로킹이 발생  DOM의 생성이 지연될수있다는 것을 의미

script 태그 위치가 중요하다

 

body요소 가장 아래에 JS를 위치시키는것은 좋은 생각이고 그 이유는

 

HTML 요소들이 스크립트 로딩지연으로 렌더링에 지장받는일이 없고,페이지 로딩시간 단축

 

DOM 완성 이전에 JS 가 DOM 을 조작하면 에러 발생

# DNS의 동작원리
https://ganzicoder.tistory.com/94

호스트의 도메인 이름 => 호스트의 네트워크 주소

 

특정 컴퓨터의 주소를 찾기위해, 컴퓨터가 이해하기 쉬운 IP 주소로 변환

 

사람이 이해하기쉽게 IP주소를 이름화

 

실제 웹주소 예시 :: 63.245.211.211

IP주소라고 하고 웹의 고유위치를 말한다

 

1.PC 브라우저에서 www.naver.com을 입력하며 PC는 미리 설정되어있는 DNS(단말에 설정되어있는 DNS = Local DNS)

에게 www.naver.com이라는  는 hostname에 대한 IP주소를 물어본다

 

2. Local DNS 에는 1번에 대한 IP 주소가 있을수도있고 없을 수도있다 만약있다면 Local DNS가 바로 PC 에 IP주소를 주고 끝난다

 

3. Local DNS 는 이제 1번에 대한 IP주소를 찾기위해 다른 DNS 서버들과 통신(DNS메시지)를 시작한다

먼저 Root DNS 서버에게 1번에 대한 IP 주소를 아는지 물어본다 이를 위해 각 Local DNS 서버엔

Root DNS 서버의 정보가 미리 설정되어있음

 

4. Root DNS 는 전세계에 13대가 구축되어있음,미국 10대 일본/네덜란드/노르웨이 각 1대

우리나라의 경우 Root DNS는 없고 미러 서버를 3대 운용중이라고한다

 

5.Root DNS 서버는 1번에 대한 IP 주소를 모른다 그래서 다시 Local DNS 서버에게 

다른 DNS 서버에게 물어보라고 응답한다

 

6. 다른 DNS 서버는 com 도메인을 관리하는 DNS 서버다

 

7. Local DNS 서버는 com 도메인을 관리하는 DNS 서버에게 다시 1번에대한 IP주소를 물어본다

 

8. 역시 com 도메인 관리하는 DNS 에도 해당정보는 없다

다시 다른 DNS에게 물어보라는 응답을한다  다른 DNS 서버는 naver.com 도메인을 관리하는 DNS 서버이다

 

9. Local DNS 서버는 naver.com 도메인을 관리하는 DNS 서버에게 1번에대한 IP 주소를 물어본다

 

10. naver.com 도메인을 관리하는 DNS 서버에는 1번 호스트네임에 대한 IP 주소가있다

그래서 Local DNS 서버에게 1번에 대한 IP 주소 222.122.195.6 이라고 응답해준다

 

11. 이를 수신한 Local DNS 는 www.naver.com  에 대한 IP 주소를 캐싱 하고(다른 사람이 물어보면 바로 응답할수있게)

그 IP 주소 정보를 단말(PC)에 전달한다

 

참조:

kkoon9.tistory.com/69?category=931254

https://ganzicoder.tistory.com/95
도메인 네임이란?

https://ganzicoder.tistory.com/96
호스팅은 무엇인가?


# 프로세스 관리
https://ganzicoder.tistory.com/97

1.프로세스

 

프로세스는 메인 메모리에 할당되어 실행중 인 상태의 프로그램을 뜻한다

프로그램은 일반적으로 하드디스크(보조기억장치)에 저장되어 아무일도 하지않는 대기상태

프로세스는 실행하면서 stack pointer , data, text ,register 등 끊임없이 변한다

프로세스는 job, task 등으로 불리기도 함

 

2. 프로세스 상태

 

New 프로그램이 메인 메모리에 할당된 상태

Ready 할당된 프로그램이 초기화와 같은 작업을통해 실행되기 윈한 모든 준비를 마친상태

Running CPU가 해당 프로세스를 실행한 상태

Waiting 프로세스가 끝나지않은 시점에서 I/O로인해 CPU 를 사용하지않고

다른작업을 수행한다(해당 작업이 끝나면 다시 CPU에의해 실행되기위해 ready로 돌아가야함)

Terminated 프로세스가 완전히 종료되는 상태

 


출처:https://velog.io/@codemcd/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9COS-5.-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EA%B4%80%EB%A6%AC
프로세스 상태전이도 이다 

New에서 프로세스가 어떤 작업에 의해 상태가 변하는지 나타내고있음

running에서 ready로 변할때 time sharing system에서 해당 프로세스가

cpu시간을 모두 소진하였을때 인터럽트에 의해 강제로 ready 상태로 변하고

cpu는 다른 프로세스를 실행시킨다.

 

3.PCB(Process Control Block)

 

PCB는 프로세스에 대한 모든 정보가 모여있는곳으로 

Task Control Block 라고도 한다 PCB안에는 프로세스의 상태, 프로세스 번호, 

해당 프로세스의 program counter , register 값,MMU 정보,CPU점유 시간등이 포함

PCB는 운영체제 내부의 프로세스를 관리하는 코드 부분에 저장되어있음


출처:https://velog.io/@codemcd/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9COS-5.-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EA%B4%80%EB%A6%AC
 

CPU는 한 프로세스가 종료될때까지 수행하는 것이 아니고 여러 프로세스를 중간 중간에 바꿔가면서 수행

CPU는 수행중인 프로세스를 나갈때, 프로세스의 정보를 어딘가에 저장하고 있어야 다음에 이 프로세스를 

수행할때 이전에 수행한 그다음부터 이어서 작업할수있다. 이러한 정보를 저장하는 곳이 PCB

 

4.프로세스 큐(Queue)

 

프로세스는 수행하면서 상태가 여러번 변하고, 변함에 따라 서비스를 받아야하는곳이 각기 다르다

프로세스는 일반적으로 여러 개가 한번에 수행되고 그에 따른 순서가 필요

순서를 대기하는곳을  큐(Queue) 라고한다


출처:https://velog.io/@codemcd/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9COS-5.-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EA%B4%80%EB%A6%AC
Job Queue HDD에있는 프로그램이 실행되려고 메인 메모리의 순서를 기다리는 큐

Ready Queue  CPU점유 순서를 기다리는 큐

Device Queue I/O를 하기위해 여러장치가 있지만 각 장치를 기다리는 큐가 각 각 존재

 

여러 큐가 존재하지만 

각 큐 내부에 저장된 실제 데이터는 각 프로세스이 PCB가 저장되어있다 

이러한 순서를 기다리는 공간이 있다면 순서를 정해주는 알고리즘이 있어야 함

위와 같은 알고리즘을 스케줄링 이라 한다

 

Job Queue - Job Scheduler(Long-term scheduler)

Ready Queue - CPU Scheduler(Short-term scheduler)

Device Queue - Device Scheduler

 

Job Queue의 순서를 정해주는 Job Scheduler를 롱 텀 스케쥴러 라고 하는데 ,스케줄링이 발생하는 시간이

비교적 오래걸려서 그렇다 

반면에 Ready Queue 의 CPU Scheduler 는 스케줄링이 발생하는 시간이 매우 짧아서 숏 텀 스케줄러라 한다

CPU Scheduler 는 프로세스가 CPU를 점유하는 순서를 정해주는데 매우 빠른시간안에 정해줘야한다

현대 컴퓨터가 여러프로그램을 동시에 사용하는것과 같은 효과를 주는 이유가

이 스케줄링속도가 매우 빠르게 이뤄져서다

 

2-1 멀티 프로그래밍

 

멀티프로그래밍은 단일프로세서(CPU) 환경에서 여러 개의 프로세스가 동시에 실행 되는 것을 뜻한다

(실제로는 동시에 실행 안되고 있음)

여러 프로세스가 실행되려면 이 프로세스들은 모두 메인 메모리에 존재해야한다

 

2-1-1 Degree of multiprogramming

 

Degree of multiprogramming 는 현재 메모리에 할당되어 있는 프로세스 개수를 말한다.

 

 

2-1-2   I/O bound process VS CPU bound process

 

프로세스는 I/O bound process 와 CPU bound process 로 나뉜다

 

I/O bound process: 해당 프로세스에서 I/O작업 (입출력)이 차지하는 비중이 높은 프로세스

 

CPU bound process: 해당 프로세스에서 CPU작업 (계산)이 차지하는 비중이 높은 프로세스

 

운영체제, job scheduller 는 I/O bound process 와 cpu bound process 를 적절히 

분배하여 메모리에 할당해줘야한다

 

2-1-3  Mediunm-term scheduller

 

 Mediunm-term scheduller 는 숏 텀 보다는 덜 발생하지만 

롱 텀 보다는 자주 발생하는 scheduller 다

운영체제가 실행하는 동안 주기적으로 메인 메모리에 있는 전체 프로세스를 검사

보조기억장치로 옮길 프로세스를 찾아 옮긴다

옮기는 기준은 여러가지있지만 대표적으론 장기간 사용하지 않는 프로세스가 있다

 

이기준으로 동작하는 것이 Swapping 이다 

이는 메인 메모리에서 장시간 사용하지 않는 프로세스를 하드디스크 

(Swap device = Backing store 일반적으로 하드디스크는 File system + Backing store 로 구성)

로 옮겨주고 (Swap out) 나중에 이 프로세스가 다시 사용되려고 하면 하드디스크에서 

해당 프로세스를 다시 메인 메모리에 할당한다 (Swap in)

 

Swap out 을 통해 메인 메모리의 공간이 생기므로 이를 더욱 효율적으로 사용할수있다

만약 Swap out 된 프로세스가 다시 Swap in 으로 메인 메모리에 할당하려고 할때

이전의 공간으로 할당되는것을 보장하지는 않음

because 위에서 언급햇듯이 swap out 으로 생긴 메모리 공간은

다른프로세스가 사용할수 있기 때문

 

2-1-4 Context Switching (문맥전환)

 

Context Swithching 은 CPU가 한 프로세스에서 다른 프로세스로 옮겨 가는 것

한 프로세스가 실행중인 것을 멈추고 다른 프로세스가 실행되는것

 

scheduller :여기서 스케줄러는 CPU 스케줄러를 말하고 CPU가 어느 프로세스를 선택할지 정한다

 

Dispatcher : 실제 context switching이 발생하면 CPU의 내부 데이터를 이전 프로세스 데이터에서

새로 시작되는 데이터로 바꿔준다 다시말해서 현재 CPU 데이터는 이전 프로세스의 PCB에 갱신

새로 시작되는 프로세스의 PCB 데이터를 CPU로 복원한다

 

Context switching overhead : Context switching 이 발생할때마다 

dispatcher 에서 수행하는 작업을 매번 수행해야하며 이 모든것은 overhead 다

문맥전환은 매우 자주 발생하는 작업이므로  overhead 를 줄이기 위해선

dispatcher 를 구현하는 코드에 대한 효율을 최대한 높여주어야함

 

 

참조:velog.io/@codemcd/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9COS-5.-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EA%B4%80%EB%A6%AC